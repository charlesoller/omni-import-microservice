// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: cast_member.sql

package db

import (
	"context"
)

const upsertCastMember = `-- name: UpsertCastMember :one
INSERT INTO cast_members (
    id, cast_id, credit_id, gender, adult, known_for_department, 
    name, original_name, popularity, profile_path
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
ON CONFLICT (id) 
DO UPDATE SET
    cast_id = EXCLUDED.cast_id,
    credit_id = EXCLUDED.credit_id,
    gender = EXCLUDED.gender,
    adult = EXCLUDED.adult,
    known_for_department = EXCLUDED.known_for_department,
    name = EXCLUDED.name,
    original_name = EXCLUDED.original_name,
    popularity = EXCLUDED.popularity,
    profile_path = EXCLUDED.profile_path
RETURNING id, cast_id, credit_id, gender, adult, known_for_department, name, original_name, popularity, profile_path
`

type UpsertCastMemberParams struct {
	ID                 int32   `json:"id"`
	CastID             int32   `json:"cast_id"`
	CreditID           string  `json:"credit_id"`
	Gender             int16   `json:"gender"`
	Adult              bool    `json:"adult"`
	KnownForDepartment string  `json:"known_for_department"`
	Name               string  `json:"name"`
	OriginalName       string  `json:"original_name"`
	Popularity         float64 `json:"popularity"`
	ProfilePath        string  `json:"profile_path"`
}

func (q *Queries) UpsertCastMember(ctx context.Context, arg UpsertCastMemberParams) (CastMember, error) {
	row := q.queryRow(ctx, q.upsertCastMemberStmt, upsertCastMember,
		arg.ID,
		arg.CastID,
		arg.CreditID,
		arg.Gender,
		arg.Adult,
		arg.KnownForDepartment,
		arg.Name,
		arg.OriginalName,
		arg.Popularity,
		arg.ProfilePath,
	)
	var i CastMember
	err := row.Scan(
		&i.ID,
		&i.CastID,
		&i.CreditID,
		&i.Gender,
		&i.Adult,
		&i.KnownForDepartment,
		&i.Name,
		&i.OriginalName,
		&i.Popularity,
		&i.ProfilePath,
	)
	return i, err
}
